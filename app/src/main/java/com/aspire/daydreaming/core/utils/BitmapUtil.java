package com.aspire.daydreaming.core.utils;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.util.Log;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * @Name: BitmapUtil * @Author: yeliang * @Date: 2016/8/25 */public class BitmapUtil {    public static final String TAG = "BitmapUtil";    public void transxImage(String fromFile, String toFile, int width, int height, int quality) {        try {            Bitmap bitmap = BitmapFactory.decodeFile(fromFile);            int bitmapWidth = bitmap.getWidth();            int bitmapHeight = bitmap.getHeight();            // 缩放图片的尺寸            float scaleWidth = (float) width / bitmapWidth;            float scaleHeight = (float) height / bitmapHeight;            Matrix matrix = new Matrix();            matrix.postScale(scaleWidth, scaleHeight);            // 产生缩放后的Bitmap对象            Bitmap resizeBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmapWidth, bitmapHeight, matrix, false);            // save file            File myCaptureFile = new File(toFile);            FileOutputStream out = new FileOutputStream(myCaptureFile);            if (resizeBitmap.compress(Bitmap.CompressFormat.JPEG, quality, out)) {                out.flush();                out.close();            }            if (!bitmap.isRecycled()) {                bitmap.recycle();//记得释放资源，否则会内存溢出            }            if (!resizeBitmap.isRecycled()) {                resizeBitmap.recycle();            }        } catch (IOException ex) {            ex.printStackTrace();        }    }    public static Bitmap zoomImage(Bitmap bgImage, double newWidth,                                   double newHeight) {        // 获取这个图片的宽和高        float width = bgImage.getWidth();        float height = bgImage.getHeight();        // 创建操作图片用的matrix对象        Matrix matrix = new Matrix();        // 计算宽高缩放率        float scaleWidth = ((float) newWidth) / width;        float scaleHeight = ((float) newHeight) / height;        // 缩放图片动作        matrix.postScale(scaleWidth, scaleHeight);        return Bitmap.createBitmap(bgImage, 0, 0, (int) width,                (int) height, matrix, true);    }    public static Bitmap imageZoom(Bitmap bitmap) {        //图片允许最大空间   单位：KB        double maxSize = 300.00;        //将bitmap放至数组中，意在bitmap的大小（与实际读取的原文件要大）        ByteArrayOutputStream bao = new ByteArrayOutputStream();        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bao);        byte[] b = bao.toByteArray();        //将字节换成KB        double mid = b.length / 1024;        //判断bitmap占用空间是否大于允许最大空间  如果大于则压缩 小于则不压缩        if (mid > maxSize) {            //获取bitmap大小 是允许最大大小的多少倍            double i = mid / maxSize;            //开始压缩  此处用到平方根 将宽带和高度压缩掉对应的平方根倍 （1.保持刻度和高度和原bitmap比率一致，压缩后也达到了最大大小占用空间的大小）            bitmap = zoomImage(bitmap, bitmap.getWidth() / Math.sqrt(i),                    bitmap.getHeight() / Math.sqrt(i));        }        return bitmap;    }    // 压缩图片方法    public static Bitmap compressImage(Bitmap image) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中        int size = baos.toByteArray().length / 1024;        Log.i(TAG, "compressImage: " + "压缩前大小" + baos.toByteArray().length / 1024);        if (baos.toByteArray().length / 1024 > 100) {    //循环判断如果压缩后图片是否大于100kb,大于继续压缩            baos.reset();//重置baos即清空baos            image.compress(Bitmap.CompressFormat.JPEG, 100 / size, baos);//这里压缩options%，把压缩后的数据存放到baos中            Log.i(TAG, "compressImage: " + "压缩后大小" + baos.toByteArray().length / 1024);        }        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中        BitmapFactory.Options option = new BitmapFactory.Options();        option.inPreferredConfig = Bitmap.Config.ARGB_8888;        option.inJustDecodeBounds = true;        return BitmapFactory.decodeStream(isBm, null, null);    }    /**     * 一种挺有效的方法，规避BitmapFactory.decodeStream或者decodeFile函数，使用BitmapFactory.decodeFileDescriptor     *     * @param path     * @return     */    public static Bitmap readBitmapByPath(String path) {        BitmapFactory.Options bfOptions = new BitmapFactory.Options();        bfOptions.inDither = false;        bfOptions.inPurgeable = true;        bfOptions.inInputShareable = true;        bfOptions.inTempStorage = new byte[32 * 1024];        File file = new File(path);        FileInputStream fs = null;        try {            fs = new FileInputStream(file);            return BitmapFactory.decodeFileDescriptor(fs.getFD(), null, bfOptions);        } catch (IOException e) {            e.printStackTrace();        } finally {            if (fs != null) {                try {                    fs.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return null;    }    // 压缩头像图片方法    public static Bitmap compressHeadImage(Bitmap image) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中        int options = 100;        while (baos.toByteArray().length / 1024 > 50) {    //循环判断如果压缩后图片是否大于50kb,大于继续压缩            baos.reset();//重置baos即清空baos            image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中            options -= 10;//每次都减少10        }        ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中        Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片        return bitmap;    }    // 获取圆角图片    public static Bitmap toRoundCorner(Bitmap bitmap, int pixels) {        Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);        Canvas canvas = new Canvas(output);        final int color = 0xff424242;        final Paint paint = new Paint();        final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());        final RectF rectF = new RectF(rect);        paint.setAntiAlias(true);        canvas.drawARGB(0, 0, 0, 0);        paint.setColor(color);        canvas.drawRoundRect(rectF, (float) pixels, (float) pixels, paint);        paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));        canvas.drawBitmap(bitmap, rect, rect, paint);        return output;    }    /**     * @param options   参数     * @param reqWidth  目标的宽度     * @param reqHeight 目标的高度     * @return     * @description 计算图片的压缩比率     */    private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {        // 源图片的高度和宽度        final int height = options.outHeight;        final int width = options.outWidth;        int inSampleSize = 1;        if (height > reqHeight || width > reqWidth) {            // 计算出实际宽高和目标宽高的比率            final int halfHeight = height / 2;            final int halfWidth = width / 2;            while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth) {                inSampleSize *= 2;            }        }        return inSampleSize;    }    /**     * @param src     * @param dstWidth     * @param dstHeight     * @return     * @description 通过传入的bitmap，进行压缩，得到符合标准的bitmap     */    private static Bitmap createScaleBitmap(Bitmap src, int dstWidth, int dstHeight, int inSampleSize) {        //如果inSampleSize是2的倍数，也就说这个src已经是我们想要的缩略图了，直接返回即可。        if (inSampleSize % 2 == 0) {            return src;        }        // 如果是放大图片，filter决定是否平滑，如果是缩小图片，filter无影响，我们这里是缩小图片，所以直接设置为false        Bitmap dst = Bitmap.createScaledBitmap(src, dstWidth, dstHeight, false);        if (src != dst) { // 如果没有缩放，那么不回收            src.recycle(); // 释放Bitmap的native像素数组        }        return dst;    }    /**     * @param res     * @param resId     * @param reqWidth     * @param reqHeight     * @return     * @description 从Resources中加载图片     */    public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {        final BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true; // 设置成了true,不占用内存，只获取bitmap宽高        BitmapFactory.decodeResource(res, resId, options); // 读取图片长款        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 调用上面定义的方法计算inSampleSize值        // 使用获取到的inSampleSize值再次解析图片        options.inJustDecodeBounds = false;        Bitmap src = BitmapFactory.decodeResource(res, resId, options); // 载入一个稍大的缩略图        return createScaleBitmap(src, reqWidth, reqHeight, options.inSampleSize); // 进一步得到目标大小的缩略图    }    /**     * @param pathName     * @param reqWidth     * @param reqHeight     * @return     * @description 从SD卡上加载图片     */    public static Bitmap decodeSampledBitmapFromFile(String pathName, int reqWidth, int reqHeight) {        final BitmapFactory.Options options = new BitmapFactory.Options();        options.inJustDecodeBounds = true;        BitmapFactory.decodeFile(pathName, options);        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);        options.inJustDecodeBounds = false;        Bitmap src = BitmapFactory.decodeFile(pathName, options);        return createScaleBitmap(src, reqWidth, reqHeight, options.inSampleSize);    }}